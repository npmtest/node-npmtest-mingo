{"/home/travis/build/npmtest/node-npmtest-mingo/test.js":"/* istanbul instrument in package npmtest_mingo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-mingo/lib.npmtest_mingo.js":"/* istanbul instrument in package npmtest_mingo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_mingo = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_mingo = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-mingo/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-mingo && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_mingo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_mingo\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_mingo.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_mingo.rollup.js'] =\n            local.assetsDict['/assets.npmtest_mingo.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_mingo.__dirname + '/lib.npmtest_mingo.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-mingo/node_modules/mingo/mingo.js":"// Mingo.js\n// Copyright (c) 2017 Francis Asante <kofrasa@gmail.com>\n// MIT\n\n;(function(root){\n\n'use strict'\n\n// global on the server, window in the browser\nvar Mingo = {}\nvar previousMingo\n\n// backup previous Mingo\nif (root !== null) {\n  previousMingo = root.Mingo\n}\n\nMingo.noConflict = function () {\n  root.Mingo = previousMingo\n  return Mingo\n}\n\nMingo.VERSION = '1.1.2'\n\n/**\n * Common references\n */\n\nvar ArrayProto = Array.prototype\nvar ObjectProto = Object.prototype\nvar stringify = JSON.stringify\n\n/**\n * Polyfills to add native methods for non-supported environments.\n */\n\n// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function (oThis) {\n    if (typeof this !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new Error('Function.prototype.bind - what is trying to be bound is not callable')\n    }\n\n    var aArgs = ArrayProto.slice.call(arguments, 1)\n    var fToBind = this\n    var fNOP = function () {}\n    var fBound = function () {\n      return fToBind.apply(\n        (this instanceof fNOP) ? this : oThis,\n        aArgs.concat(ArrayProto.slice.call(arguments))\n      )\n    }\n\n    if (this.prototype) {\n      // Function.prototype doesn't have a prototype property\n      fNOP.prototype = this.prototype\n    }\n    fBound.prototype = new fNOP()\n\n    return fBound\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find\nif (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, 'find', {\n    value: function(predicate) {\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined')\n      }\n\n      var o = Object(this)\n      var len = o.length >>> 0\n\n      if (typeof predicate !== 'function') {\n        throw new TypeError('predicate must be a function')\n      }\n\n      var thisArg = arguments[1]\n      var k = 0\n\n      while (k < len) {\n        var kValue = o[k]\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return kValue\n        }\n        k++\n      }\n      return undefined\n    }\n  })\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex\nif (!Array.prototype.findIndex) {\n  Object.defineProperty(Array.prototype, 'findIndex', {\n    value: function(predicate) {\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined')\n      }\n\n      var o = Object(this)\n      var len = o.length >>> 0\n\n      if (typeof predicate !== 'function') {\n        throw new TypeError('predicate must be a function')\n      }\n\n      var thisArg = arguments[1]\n      var k = 0\n      while (k < len) {\n        var kValue = o[k]\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return k\n        }\n        k++\n      }\n      return -1\n    }\n  })\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes\nif (!Array.prototype.includes) {\n  Object.defineProperty(Array.prototype, 'includes', {\n    value: function(searchElement, fromIndex) {\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined')\n      }\n\n      var o = Object(this)\n      var len = o.length >>> 0\n\n      if (len === 0) {\n        return false\n      }\n      var n = fromIndex | 0\n      var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0)\n\n      while (k < len) {\n        if (o[k] === searchElement) {\n          return true\n        }\n        k++\n      }\n      return false\n    }\n  })\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nif (typeof Object.assign != 'function') {\n  Object.assign = function(target, varArgs) { // .length of function is 2\n\n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object')\n    }\n\n    var to = Object(target)\n    var args = ArrayProto.slice.call(arguments)\n\n    for (var index = 1; index < args.length; index++) {\n      var nextSource = args[index]\n\n      if (nextSource != null) { // Skip over if undefined or null\n        for (var nextKey in nextSource) {\n          // Avoid bugs when hasOwnProperty is shadowed\n          if (ObjectProto.hasOwnProperty.call(nextSource, nextKey)) {\n            to[nextKey] = nextSource[nextKey]\n          }\n        }\n      }\n    }\n    return to\n  }\n}\n\n// http://tokenposts.blogspot.co.za/2012/04/javascript-objectkeys-browser.html\nif (!Object.keys) {\n  Object.keys = function (o) {\n    if (o !== Object(o)) {\n      throw new TypeError('Object.keys called on a non-object')\n    }\n\n    var result = []\n    for (var k in o) {\n      if (ObjectProto.hasOwnProperty.call(o, k)) {\n        result.push(k)\n      }\n    }\n    return result\n  }\n}\n\n// https://github.com/es-shims/Object.values/blob/master/implementation.js\nif (!Object.values) {\n  Object.values = function (o) {\n    if (o !== Object(o)) {\n      throw new TypeError('Object.values called on a non-object')\n    }\n    var result = []\n    for (var k in o) {\n      if (ObjectProto.hasOwnProperty.call(o, k)) {\n        result.push(o[k])\n      }\n    }\n    return result\n  }\n}\n\nfunction util () {\n  return {\n    'isArray': isArray,\n    'isBoolean': isBoolean,\n    'isDate': isDate,\n    'isEmpty': isEmpty,\n    'isEqual': isEqual,\n    'isFunction': isFunction,\n    'isNil': isNil,\n    'isNull': isNull,\n    'isNumber': isNumber,\n    'isObject': isObject,\n    'isObjectLike': isObjectLike,\n    'isRegExp': isRegExp,\n    'isString': isString,\n    'isUndefined': isUndefined\n  }\n}\n\nfunction assert (condition, message) {\n  if (falsey(condition)) err(message)\n}\n\nfunction assertExists (value) {\n  return assert(!isUndefined(value))\n}\n\n/**\n * Deep clone an object\n */\nfunction clone (arg) {\n  switch (getType(arg)) {\n    case 'array':\n      return arg.map(clone)\n    case 'object':\n      return map(arg, clone)\n    default:\n      return arg\n  }\n}\n\nfunction isType (v, n) { return getType(v) === n }\nfunction isBoolean (v) { return isType(v, 'boolean') }\nfunction isString (v) { return isType(v, 'string') }\nfunction isNumber (v) { return isType(v, 'number') }\nfunction isArray (v) { return isType(v, 'array') }\nfunction isObject (v) { return isType(v, 'object') }\nfunction isObjectLike (v) { return v === Object(v) } // objects, arrays, functions\nfunction isDate (v) { return isType(v, 'date') }\nfunction isRegExp (v, t) { return isType(v, 'regexp') }\nfunction isFunction (v, t) { return isType(v, 'function') }\nfunction isNil (v) { return isNull(v) || isUndefined(v) }\nfunction isNull (v) { return isType(v, 'null') }\nfunction isUndefined (v) { return isType(v, 'undefined') }\nfunction inArray (arr, item) { return arr.includes(item) }\nfunction notInArray (arr, item) { return !arr.includes(item) }\nfunction truthy (arg) { return !!arg }\nfunction falsey (arg) { return !arg }\nfunction isEmpty (x) {\n  return isNil(x) ||\n    isArray(x) && x.length === 0 ||\n    isObject(x) && keys(x).length === 0 ||\n    !x\n}\n// TODO: convert arguments to array\nfunction array (x) { return isArray(x) ? x : [x] }\nfunction getType (value) { return ObjectProto.toString.call(value).match(/\\s(\\w+)/)[1].toLowerCase() }\nfunction has (obj, prop) { return ObjectProto.hasOwnProperty.call(obj, prop) }\nfunction err (s) { throw new Error(s) }\nfunction keys (o) { return Object.keys(o) }\n\n// ////////////////// UTILS ////////////////////\n\n/**\n * Iterate over an array or object\n * @param  {Array|Object} obj An object-like value\n * @param  {Function} callback The callback to run per item\n * @param  {*}   ctx  The object to use a context\n * @return {void}\n */\nfunction each (obj, callback, ctx) {\n  assert(obj === Object(obj), \"Cannot iterate over object of type '\" + getType(obj) + \"'\")\n  if (isArray(obj)) {\n    obj.forEach(callback, ctx)\n  } else {\n    for (var k in obj) {\n      if (has(obj, k)) {\n        callback.call(ctx, obj[k], k)\n      }\n    }\n  }\n}\n\n/**\n * Transform values in a collection\n *\n * @param  {Array|Object}   obj   An array/object whose values to transform\n * @param  {Function} callback The transform function\n * @param  {*}   ctx The value to use as the \"this\" context for the transform\n * @return {Array|Object} Result object after applying the transform\n */\nfunction map (obj, callback, ctx) {\n  if (isArray(obj)) {\n    return obj.map(callback, ctx)\n  } else if (isObject(obj)) {\n    var o = {}\n    var arr = keys(obj)\n    for (var k, i = 0, len = arr.length; i < len; i++) {\n      k = arr[i]\n      o[k] = callback.call(ctx, obj[k], k)\n    }\n    return o\n  }\n  err('Input must be an Array or Object type')\n}\n\n/**\n * Returns the intersection between two arrays\n *\n * @param  {Array} xs The first array\n * @param  {Array} ys The second array\n * @return {Array}    Result array\n */\nfunction intersection (xs, ys) {\n  return xs.filter(inArray.bind(null, ys))\n}\n\n/**\n * Returns the union of two arrays\n *\n * @param  {Array} xs The first array\n * @param  {Array} ys The second array\n * @return {Array}   The result array\n */\nfunction union (xs, ys) {\n  var arr = []\n  into(arr, xs)\n  into(arr, ys.filter(notInArray.bind(null, xs)))\n  return arr\n}\n\n/**\n * Flatten the array\n *\n * @param  {Array} xs The array to flatten\n * @return {Array} depth The number of nested lists to interate\n */\nfunction flatten (xs, depth) {\n  assert(isArray(xs), 'Input must be an Array')\n  var arr = []\n  var unwrap = function (ys, iter) {\n    for (var i = 0, len = ys.length; i < len; i++) {\n      if (isArray(ys[i]) && (iter > 0 || iter < 0)) {\n        unwrap(ys[i], Math.max(-1, iter - 1))\n      } else {\n        arr.push(ys[i])\n      }\n    }\n  }\n  unwrap(xs, depth || -1)\n  return arr\n}\n\n/**\n * Determine whether two values are the same or strictly equivalent\n *\n * @param  {*}  a The first value\n * @param  {*}  b The second value\n * @return {Boolean}   Result of comparison\n */\nfunction isEqual (a, b) {\n  // strictly equal must be equal.\n  if (a === b) return true\n\n  // unequal types cannot be equal.\n  var type = getType(a)\n  if (type !== getType(b)) return false\n\n  // we treat NaN as the same\n  if (type === 'number' && isNaN(a) && isNaN(b)) return true\n\n  // leverage toString for Date and RegExp types\n  if (inArray(['date', 'regexp'], type)) return a.toString() === b.toString()\n\n  var i // loop counter\n  var len // loop length\n\n  if (type === 'array') {\n    if (a.length === b.length && a.length === 0) return true\n    if (a.length !== b.length) return false\n    for (i = 0, len = a.length; i < len; i++) {\n      if (!isEqual(a[i], b[i])) return false\n    }\n  } else if ([a, b].every(isObject)) {\n    // deep compare objects\n    var ka = keys(a)\n    var kb = keys(b)\n\n    // check length of keys early\n    if (ka.length !== kb.length) return false\n\n    // we know keys are strings so we sort before comparing\n    ka.sort()\n    kb.sort()\n\n    // compare keys\n    if (!isEqual(ka, kb)) return false\n\n    // back to the drawing board\n    for (i = 0, len = ka.length; i < len; i++) {\n      var temp = ka[i]\n      if (!isEqual(a[temp], b[temp])) return false\n    }\n  } else {\n    // we do not know how to compare unknown types\n    return false\n  }\n  // best effort says values are equal :)\n  return true\n}\n\n/**\n * Return a new unique version of the collection\n * @param  {Array} xs The input collection\n * @return {Array}    A new collection with unique values\n */\nfunction unique (xs) {\n  var h = {}\n  var arr = []\n  each(xs, function (item) {\n    var k = getHash(item)\n    if (!has(h, k)) {\n      arr.push(item)\n      h[k] = 0\n    }\n  })\n  return arr\n}\n\n// encode value using a simple optimistic scheme\nfunction encode (value) {\n  return JSON.stringify({'': value}) + getType(value) + value\n}\n\n// http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n// http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/\nfunction getHash (value) {\n  var hash = 0, i, chr, len, s = encode(value)\n  if (s.length === 0) return hash\n  for (i = 0, len = s.length; i < len; i++) {\n    chr = s.charCodeAt(i)\n    hash = ((hash << 5) - hash) + chr\n    hash |= 0 // Convert to 32bit integer\n  }\n  return hash.toString()\n}\n\n/**\n * Returns a (stably) sorted copy of list, ranked in ascending order by the results of running each value through iteratee\n * @param  {Array}   collection [description]\n * @param  {Function} fn The function used to sort\n * @return {Array} Returns a new sorted array by the given iteratee\n */\nfunction sortBy (collection, fn, ctx) {\n  var sortKeys = {}\n  var sorted = []\n  var key, val, hash, len = collection.length\n  for (var i = 0; i < len; i++) {\n    val = collection[i]\n    key = fn.call(ctx, val, i)\n    hash = getHash(val)\n    if (!has(sortKeys, hash)) {\n      sortKeys[hash] = [key, i]\n    }\n    sorted.push(clone(val))\n  }\n  // use native array sorting but enforce stableness\n  sorted.sort(function (a, b) {\n    var A = sortKeys[getHash(a)]\n    var B = sortKeys[getHash(b)]\n    if (A[0] < B[0]) return -1\n    if (A[0] > B[0]) return 1\n    if (A[1] < B[1]) return -1\n    if (A[1] > B[1]) return 1\n    return 0\n  })\n  assert(sorted.length === collection.length, 'sortBy must retain collection length')\n  return sorted\n}\n\n/**\n * Groups the collection into sets by the returned key\n *\n * @param collection\n * @param fn {function} to compute the group key of an item in the collection\n */\nfunction groupBy (collection, fn, ctx) {\n  var result = {\n    'keys': [],\n    'groups': []\n  }\n\n  var lookup = {}\n\n  each(collection, function (obj) {\n    var key = fn.call(ctx, obj)\n    var hash = getHash(key)\n    var index = -1\n\n    if (isUndefined(lookup[hash])) {\n      index = result.keys.length\n      lookup[hash] = index\n      result.keys.push(key)\n      result.groups.push([])\n    }\n    index = lookup[hash]\n    result.groups[index].push(obj)\n  })\n\n  assert(result.keys.length === result.groups.length, 'Cardinality must be equal for groups and keys')\n  return result\n}\n\nfunction into (target, xs) {\n  ArrayProto.push.apply(target, xs)\n}\n\n/**\n * Internal functions\n */\n\n// Settings used by Mingo internally\nvar settings = {\n  key: '_id'\n}\n\n/**\n * Setup default settings for Mingo\n * @param options\n */\nMingo.setup = function (options) {\n  Object.assign(settings, options || {})\n}\n\n/**\n * Internally used Mingo helpers.\n * NB: This is not guaranteed to be available in later versions\n */\nMingo._internal = function() {\n  return Object.assign(util(), {\n    'computeValue': computeValue\n  })\n}\n\n/**\n * Implementation of system variables\n * @type {Object}\n */\nvar systemVariables = {\n  '$$ROOT': function (obj, expr, opt) { return opt.root },\n  '$$CURRENT': function (obj, expr, opt) { return obj }\n}\n\n/**\n * Implementation of $redact variables\n * @type {Object}\n */\nvar redactVariables = {\n  '$$KEEP': function (obj, expr, opt) { return obj },\n  '$$PRUNE': function (obj, expr, opt) { return undefined },\n  '$$DESCEND': function (obj, expr, opt) {\n    // traverse nested documents iff there is a $cond\n    if (!has(expr, '$cond')) return obj\n\n    var result\n\n    each(obj, function (current, key) {\n      if (isObjectLike(current)) {\n        if (isArray(current)) {\n          result = []\n          each(current, function (elem, index) {\n            if (isObject(elem)) {\n              elem = redactObj(elem, expr, opt)\n            }\n            if (!isUndefined(elem)) result.push(elem)\n          })\n        } else {\n          result = redactObj(current, expr, opt)\n        }\n\n        if (isUndefined(result)) {\n          delete obj[key] // pruned result\n        } else {\n          obj[key] = result\n        }\n      }\n    })\n    return obj\n  }\n}\n\n// system varibiables\nvar SYS_VARS = keys(systemVariables)\nvar REDACT_VARS = keys(redactVariables)\n\n/**\n * Returns the key used as the collection's objects ids\n */\nfunction keyId () {\n  return settings.key\n}\n\n/**\n * Retrieve the value of a given key on an object\n * @param obj\n * @param field\n * @returns {*}\n * @private\n */\nfunction getValue (obj, field) {\n  return obj[field]\n}\n\n/**\n * Resolve the value of the field (dot separated) on the given object\n * @param obj {Object} the object context\n * @param selector {String} dot separated path to field\n * @returns {*}\n */\nfunction resolve (obj, selector, deepFlag) {\n  var names = selector.split('.')\n  var value = obj\n\n  for (var i = 0; i < names.length; i++) {\n    var isText = isNull(names[i].match(/^\\d+$/))\n\n    if (isText && isArray(value)) {\n      // On the first iteration, we check if we received a stop flag.\n      // If so, we stop to prevent iterating over a nested array value\n      // on consecutive object keys in the selector.\n      if (deepFlag === true && i === 0) {\n        return value\n      }\n\n      value = value.map(function (item) {\n        return resolve(item, names[i], true)\n      })\n\n      // we unwrap for arrays of unit length\n      // this avoids excess wrapping when resolving deeply nested arrays\n      if (value.length === 1) {\n        value = value[0]\n      }\n    } else {\n      value = getValue(value, names[i])\n      deepFlag = false // reset stop flag when we do a direct lookup\n    }\n\n    if (isUndefined(value)) break\n  }\n\n  return value\n}\n\n/**\n * Returns the full object to the resolved value given by the selector.\n * This function excludes empty values as they aren't practically useful.\n *\n * @param obj {Object} the object context\n * @param selector {String} dot separated path to field\n */\nfunction resolveObj (obj, selector) {\n  if (isUndefined(obj)) return\n\n  var names = selector.split('.')\n  var key = names[0]\n  // get the next part of the selector\n  var next = names.length === 1 || names.slice(1).join('.')\n  var isIndex = key.match(/^\\d+$/) !== null\n  var hasNext = names.length > 1\n  var result\n  var value\n\n  try {\n    if (isArray(obj)) {\n      if (isIndex) {\n        result = getValue(obj, key)\n        if (hasNext) {\n          result = resolveObj(result, next)\n        }\n        assertExists(result)\n        result = [result]\n      } else {\n        result = []\n        each(obj, function (item) {\n          value = resolveObj(item, selector)\n          if (!isUndefined(value)) result.push(value)\n        })\n        assert(result.length > 0)\n      }\n    } else {\n      value = getValue(obj, key)\n      if (hasNext) {\n        value = resolveObj(value, next)\n      }\n      assertExists(value)\n      result = {}\n      result[key] = value\n    }\n  } catch (e) {\n    result = undefined\n  }\n\n  return result\n}\n\n/**\n * Walk the object graph and execute the given transform function\n * @param  {Object|Array} obj   The object to traverse\n * @param  {String} selector    The selector\n * @param  {Function} transformFn Function to execute for value at the end the traversal\n * @param  {Boolean} force Force generating missing parts of object graph\n * @return {*}\n */\nfunction traverse (obj, selector, fn, force) {\n  var names = selector.split('.')\n  var key = names[0]\n  var next = names.length === 1 || names.slice(1).join('.')\n\n  if (names.length === 1) {\n    fn(obj, key)\n  } else { // nested objects\n    if (isArray(obj) && !/^\\d+$/.test(key)) {\n      each(obj, function (item) {\n        traverse(item, selector, fn, force)\n      })\n    } else {\n      // force the rest of the graph while traversing\n      if (force === true) {\n        var exists = has(obj, key)\n        if (!exists || isNil(obj[key])) {\n          obj[key] = {}\n        }\n      }\n      traverse(obj[key], next, fn, force)\n    }\n  }\n}\n\n/**\n * Set the value of the given object field\n *\n * @param obj {Object|Array} the object context\n * @param selector {String} path to field\n * @param value {*} the value to set\n */\nfunction setValue (obj, selector, value) {\n  traverse(obj, selector, function (item, key) {\n    item[key] = value\n  }, true)\n}\n\nfunction removeValue (obj, selector) {\n  traverse(obj, selector, function (item, key) {\n    if (isArray(item) && /^\\d+$/.test(key)) {\n      item.splice(parseInt(key), 1)\n    } else if (isObject(item)) {\n      delete item[key]\n    }\n  })\n}\n\n\n// quick reference for\nvar primitives = [\n  isString, isBoolean, isNumber, isDate, isNil, isRegExp\n]\n\nfunction isPrimitive (value) {\n  for (var i = 0; i < primitives.length; i++) {\n    if (primitives[i](value)) {\n      return true\n    }\n  }\n  return false\n}\n\n// primitives and user-defined types\nfunction isSimpleType (value) {\n  return isPrimitive(value) || !isObjectLike(value)\n}\n\n/**\n * Simplify expression for easy evaluation with query operators map\n * @param expr\n * @returns {*}\n */\nfunction normalize (expr) {\n  // normalized primitives\n  if (isSimpleType(expr)) {\n    return isRegExp(expr) ? {'$regex': expr} : {'$eq': expr}\n  }\n\n  // normalize object expression\n  if (isObjectLike(expr)) {\n    var exprKeys = keys(expr)\n    var notQuery = intersection(ops(KEY_QUERY), exprKeys).length === 0\n\n    // no valid query operator found, so we do simple comparison\n    if (notQuery) {\n      return {'$eq': expr}\n    }\n\n    // ensure valid regex\n    if (inArray(exprKeys, '$regex')) {\n      var regex = expr['$regex']\n      var options = expr['$options'] || ''\n      var modifiers = ''\n      if (isString(regex)) {\n        modifiers += (regex.ignoreCase || options.indexOf('i') >= 0) ? 'i' : ''\n        modifiers += (regex.multiline || options.indexOf('m') >= 0) ? 'm' : ''\n        modifiers += (regex.global || options.indexOf('g') >= 0) ? 'g' : ''\n        regex = new RegExp(regex, modifiers)\n      }\n      expr['$regex'] = regex\n      delete expr['$options']\n    }\n  }\n\n  return expr\n}\n\n/**\n * Computes the actual value of the expression using the given object as context\n *\n * @param obj the current object from the collection\n * @param expr the expression for the given field\n * @param field the field name (may also be an aggregate operator)\n * @returns {*}\n */\nfunction computeValue (obj, expr, field, opt) {\n  opt = opt || {}\n  opt.root = opt.root || clone(obj)\n\n  // if the field of the object is a valid operator\n  if (inArray(ops(KEY_AGGREGATE), field)) {\n    return aggregateOperators[field](obj, expr, opt)\n  }\n\n  // we also handle $group accumulator operators\n  if (inArray(ops(KEY_GROUP), field)) {\n    // we first fully resolve the expression\n    obj = computeValue(obj, expr, null, opt)\n    assert(isArray(obj), 'Must use collection type with ' + field + ' operator')\n    // we pass a null expression because all values have been resolved\n    return groupOperators[field](obj, null, opt)\n  }\n\n  // if expr is a variable for an object field\n  // field not used in this case\n  if (isString(expr) && expr.length > 0 && expr[0] === '$') {\n    // we return system variables as literals\n    if (inArray(SYS_VARS, expr)) {\n      return systemVariables[expr](obj, null, opt)\n    } else if (inArray(REDACT_VARS, expr)) {\n      return expr\n    }\n\n    // handle selectors with explicit prefix\n    var sysVar = SYS_VARS.filter(function (v) { return expr.indexOf(v + '.') === 0 })\n    if (sysVar.length === 1) {\n      sysVar = sysVar[0]\n      if (sysVar === '$$ROOT') {\n        obj = opt.root\n      }\n      expr = expr.substr(sysVar.length) // '.' prefix will be sliced off below\n    }\n\n    return resolve(obj, expr.slice(1))\n  }\n\n  // check and return value if already in a resolved state\n  switch (getType(expr)) {\n    case 'array':\n      return expr.map(function (item) {\n        return computeValue(obj, item, null)\n      })\n    case 'object':\n      var result = {}\n      for (var key in expr) {\n        if (has(expr, key)) {\n          result[key] = computeValue(obj, expr[key], key, opt)\n          // must run ONLY one aggregate operator per expression\n          // if so, return result of the computed value\n          if (inArray(ops(KEY_AGGREGATE), key)) {\n            // there should be only one operator\n            assert(keys(expr).length === 1, \"Invalid aggregation expression '\" + stringify(expr) + \"'\")\n            result = result[key]\n            break\n          }\n        }\n      }\n      return result\n    default:\n      return clone(expr)\n  }\n}\n\n/**\n * Returns a slice of the array\n *\n * @param  {Array} xs\n * @param  {Number} skip\n * @param  {Number} limit\n * @return {Array}\n */\nfunction slice (xs, skip, limit) {\n  // MongoDB $slice works a bit differently from Array.slice\n  // Uses single argument for 'limit' and array argument [skip, limit]\n  if (isNil(limit)) {\n    if (skip < 0) {\n      skip = Math.max(0, xs.length + skip)\n      limit = xs.length - skip + 1\n    } else {\n      limit = skip\n      skip = 0\n    }\n  } else {\n    if (skip < 0) {\n      skip = Math.max(0, xs.length + skip)\n    }\n    assert(limit > 0, 'Invalid argument value for $slice operator. Limit must be a positive number')\n    limit += skip\n  }\n  return ArrayProto.slice.apply(xs, [skip, limit])\n}\n\n/**\n * Compute the standard deviation of the dataset\n * @param  {Object} ctx An object of the context. Includes \"dataset:Array\" and \"sampled:Boolean\".\n * @return {Number}\n */\nfunction stddev (ctx) {\n  var sum = ctx.dataset.reduce(function (acc, n) { return acc + n }, 0)\n  var N = ctx.dataset.length || 1\n  var err = ctx.sampled === true ? 1 : 0\n  var avg = sum / (N - err)\n  return Math.sqrt(\n    ctx.dataset.reduce(function (acc, n) { return acc + Math.pow(n - avg, 2) }, 0) / N\n  )\n}\n\n/**\n * Redact an object\n * @param  {Object} obj The object to redact\n * @param  {*} expr The redact expression\n * @param  {*} opt  Options for value\n * @return {*} Returns the redacted value\n */\nfunction redactObj (obj, expr, opt) {\n  opt = opt || {}\n  opt.root = opt.root || clone(obj)\n\n  var result = computeValue(obj, expr, null, opt)\n  return inArray(REDACT_VARS, result)\n    ? redactVariables[result](obj, expr, opt)\n    : result\n}\n\n/**\n * Aggregator for defining filter using mongoDB aggregation pipeline syntax\n *\n * @param operators an Array of pipeline operators\n * @constructor\n */\nMingo.Aggregator = function (operators) {\n  if (!(this instanceof Mingo.Aggregator)) return new Mingo.Aggregator(operators)\n\n  this.__operators = operators\n}\n\n/**\n * Apply the pipeline operations over the collection by order of the sequence added\n *\n * @param collection an array of objects to process\n * @param query the `Query` object to use as context\n * @returns {Array}\n */\nMingo.Aggregator.prototype.run = function (collection, query) {\n  if (!isEmpty(this.__operators)) {\n    // run aggregation pipeline\n    for (var i = 0; i < this.__operators.length; i++) {\n      var operator = this.__operators[i]\n      var key = keys(operator)\n      if (key.length === 1 && inArray(ops(KEY_PIPELINE), key[0])) {\n        key = key[0]\n        if (query instanceof Mingo.Query) {\n          collection = pipelineOperators[key].call(query, collection, operator[key])\n        } else {\n          collection = pipelineOperators[key](collection, operator[key])\n        }\n      } else {\n        except(\"Invalid aggregation operator '\" + key + \"'\")\n      }\n    }\n  }\n  return collection\n}\n\n/**\n * Cursor to iterate and perform filtering on matched objects\n * @param collection\n * @param query\n * @param projection\n * @constructor\n */\nMingo.Cursor = function (collection, query, projection) {\n  if (!(this instanceof Mingo.Cursor)) {\n    return new Mingo.Cursor(collection, query, projection)\n  }\n\n  this.__query = query\n  this.__collection = collection\n  this.__projection = projection || query.__projection\n  this.__operators = {}\n  this.__result = false\n  this.__position = 0\n}\n\nMingo.Cursor.prototype = {\n\n  _fetch: function () {\n    var self = this\n\n    if (this.__result !== false) {\n      return this.__result\n    }\n\n    // inject projection operator\n    if (isObject(this.__projection)) {\n      Object.assign(this.__operators, {'$project': this.__projection})\n    }\n\n    if (!isArray(this.__collection)) {\n      except('Input collection is not of valid type. Must be an Array.')\n    }\n\n    // filter collection\n    this.__result = this.__collection.filter(this.__query.test, this.__query)\n    var pipeline = []\n\n    each(['$sort', '$skip', '$limit', '$project'], function (op) {\n      if (has(self.__operators, op)) {\n        var selected = {}\n        selected[op] = self.__operators[op]\n        pipeline.push(selected)\n      }\n    })\n\n    if (pipeline.length > 0) {\n      var aggregator = new Mingo.Aggregator(pipeline)\n      this.__result = aggregator.run(this.__result, this.__query)\n    }\n    return this.__result\n  },\n\n  /**\n   * Fetch and return all matched results\n   * @returns {Array}\n   */\n  all: function () {\n    return this._fetch()\n  },\n\n  /**\n   * Fetch and return the first matching result\n   * @returns {Object}\n   */\n  first: function () {\n    return this.count() > 0 ? this._fetch()[0] : null\n  },\n\n  /**\n   * Fetch and return the last matching object from the result\n   * @returns {Object}\n   */\n  last: function () {\n    return this.count() > 0 ? this._fetch()[this.count() - 1] : null\n  },\n\n  /**\n   * Counts the number of matched objects found\n   * @returns {Number}\n   */\n  count: function () {\n    return this._fetch().length\n  },\n\n  /**\n   * Returns a cursor that begins returning results only after passing or skipping a number of documents.\n   * @param {Number} n the number of results to skip.\n   * @return {Mingo.Cursor} Returns the cursor, so you can chain this call.\n   */\n  skip: function (n) {\n    Object.assign(this.__operators, {'$skip': n})\n    return this\n  },\n\n  /**\n   * Constrains the size of a cursor's result set.\n   * @param {Number} n the number of results to limit to.\n   * @return {Mingo.Cursor} Returns the cursor, so you can chain this call.\n   */\n  limit: function (n) {\n    Object.assign(this.__operators, {'$limit': n})\n    return this\n  },\n\n  /**\n   * Returns results ordered according to a sort specification.\n   * @param {Object} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending\n   * @return {Mingo.Cursor} Returns the cursor, so you can chain this call.\n   */\n  sort: function (modifier) {\n    Object.assign(this.__operators, {'$sort': modifier})\n    return this\n  },\n\n  /**\n   * Returns the next document in a cursor.\n   * @returns {Object | Boolean}\n   */\n  next: function () {\n    if (this.hasNext()) {\n      return this._fetch()[this.__position++]\n    }\n    return null\n  },\n\n  /**\n   * Returns true if the cursor has documents and can be iterated.\n   * @returns {boolean}\n   */\n  hasNext: function () {\n    return this.count() > this.__position\n  },\n\n  /**\n   * Specifies the exclusive upper bound for a specific field\n   * @param expr\n   * @returns {Number}\n   */\n  max: function (expr) {\n    return groupOperators.$max(this._fetch(), expr)\n  },\n\n  /**\n   * Specifies the inclusive lower bound for a specific field\n   * @param expr\n   * @returns {Number}\n   */\n  min: function (expr) {\n    return groupOperators.$min(this._fetch(), expr)\n  },\n\n  /**\n   * Applies a function to each document in a cursor and collects the return values in an array.\n   * @param callback\n   * @returns {Array}\n   */\n  map: function (callback) {\n    return map(this._fetch(), callback)\n  },\n\n  /**\n   * Applies a JavaScript function for every document in a cursor.\n   * @param callback\n   */\n  forEach: function (callback) {\n    each(this._fetch(), callback)\n  }\n}\n\n/**\n * Query object to test collection elements with\n * @param criteria the pass criteria for the query\n * @param projection optional projection specifiers\n * @constructor\n */\nMingo.Query = function (criteria, projection) {\n  if (!(this instanceof Mingo.Query)) return new Mingo.Query(criteria, projection)\n\n  this.__criteria = criteria\n  this.__projection = projection\n  this.__compiled = []\n  this._compile()\n}\n\nMingo.Query.prototype = {\n\n  _compile: function () {\n    if (isEmpty(this.__criteria)) return\n\n    assert(isObject(this.__criteria), 'Criteria must be of type Object')\n\n    for (var field in this.__criteria) {\n      if (has(this.__criteria, field)) {\n        var expr = this.__criteria[field]\n        if (inArray(['$and', '$or', '$nor', '$where'], field)) {\n          this._processOperator(field, field, expr)\n        } else {\n          // normalize expression\n          expr = normalize(expr)\n          for (var op in expr) {\n            if (has(expr, op)) {\n              this._processOperator(field, op, expr[op])\n            }\n          }\n        }\n      }\n    }\n  },\n\n  _processOperator: function (field, operator, value) {\n    if (inArray(ops(KEY_QUERY), operator)) {\n      this.__compiled.push(queryOperators[operator](field, value))\n    } else {\n      except(\"Invalid query operator '\" + operator + \"' detected\")\n    }\n  },\n\n  /**\n   * Checks if the object passes the query criteria. Returns true if so, false otherwise.\n   * @param obj\n   * @returns {boolean}\n   */\n  test: function (obj) {\n    for (var i = 0; i < this.__compiled.length; i++) {\n      if (!this.__compiled[i].test(obj)) {\n        return false\n      }\n    }\n    return true\n  },\n\n  /**\n   * Performs a query on a collection and returns a cursor object.\n   * @param collection\n   * @param projection\n   * @returns {Mingo.Cursor}\n   */\n  find: function (collection, projection) {\n    return new Mingo.Cursor(collection, this, projection)\n  },\n\n  /**\n   * Remove matched documents from the collection returning the remainder\n   * @param collection\n   * @returns {Array}\n   */\n  remove: function (collection) {\n    var self = this\n    return collection.reduce(function(acc, obj) {\n      if (!self.test(obj)) {\n        acc.push(obj)\n      }\n      return acc\n    }, [])\n  }\n}\n\n\n/**\n * Group Accumulator Operators. https://docs.mongodb.com/manual/reference/operator/aggregation-group/\n */\n\nvar groupOperators = {\n\n  /**\n   * Returns an array of all the unique values for the selected field among for each document in that group.\n   *\n   * @param collection\n   * @param expr\n   * @returns {*}\n   */\n  $addToSet: function (collection, expr) {\n    return unique(this.$push(collection, expr))\n  },\n\n  /**\n   * Returns the sum of all the values in a group.\n   *\n   * @param collection\n   * @param expr\n   * @returns {*}\n   */\n  $sum: function (collection, expr) {\n    if (!isArray(collection)) return 0\n\n    if (isNumber(expr)) {\n      // take a short cut if expr is number literal\n      return collection.length * expr\n    }\n    return this.$push(collection, expr).filter(isNumber).reduce(function (acc, n) {\n      return acc + n\n    }, 0)\n  },\n\n  /**\n   * Returns the highest value in a group.\n   *\n   * @param collection\n   * @param expr\n   * @returns {*}\n   */\n  $max: function (collection, expr) {\n    var mapped = this.$push(collection, expr)\n    return mapped.reduce(function (acc, n) {\n      if (isNil(acc) || n > acc) return n\n      return acc\n    }, undefined)\n  },\n\n  /**\n   * Returns the lowest value in a group.\n   *\n   * @param collection\n   * @param expr\n   * @returns {*}\n   */\n  $min: function (collection, expr) {\n    var mapped = this.$push(collection, expr)\n    return mapped.reduce(function (acc, n) {\n      if (isNil(acc) || n < acc) return n\n      return acc\n    }, undefined)\n  },\n\n  /**\n   * Returns an average of all the values in a group.\n   *\n   * @param collection\n   * @param expr\n   * @returns {number}\n   */\n  $avg: function (collection, expr) {\n    var dataset = this.$push(collection, expr).filter(isNumber)\n    var sum = dataset.reduce(function (acc, n) { return acc + n }, 0)\n    return sum / (dataset.length || 1)\n  },\n\n  /**\n   * Returns an array of all values for the selected field among for each document in that group.\n   *\n   * @param collection\n   * @param expr\n   * @returns {Array|*}\n   */\n  $push: function (collection, expr) {\n    if (isNil(expr)) return collection\n\n    return collection.map(function (obj) {\n      return computeValue(obj, expr, null)\n    })\n  },\n\n  /**\n   * Returns the first value in a group.\n   *\n   * @param collection\n   * @param expr\n   * @returns {*}\n   */\n  $first: function (collection, expr) {\n    return (collection.length > 0) ? computeValue(collection[0], expr) : undefined\n  },\n\n  /**\n   * Returns the last value in a group.\n   *\n   * @param collection\n   * @param expr\n   * @returns {*}\n   */\n  $last: function (collection, expr) {\n    return (collection.length > 0) ? computeValue(collection[collection.length - 1], expr) : undefined\n  },\n\n  /**\n   * Returns the population standard deviation of the input values.\n   * @param  {Array} collection\n   * @param  {Object} expr\n   * @return {Number}\n   */\n  $stdDevPop: function (collection, expr) {\n    var dataset = this.$push(collection, expr).filter(isNumber)\n    return stddev({ dataset: dataset, sampled: false })\n  },\n\n  /**\n   * Returns the sample standard deviation of the input values.\n   * @param  {Array} collection\n   * @param  {Object} expr\n   * @return {Number|null}\n   */\n  $stdDevSamp: function (collection, expr) {\n    var dataset = this.$push(collection, expr).filter(isNumber)\n    return stddev({ dataset: dataset, sampled: true })\n  }\n}\n\n/**\n * Pipeline Aggregation Stages. https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/\n */\nvar pipelineOperators = {\n\n  /**\n   * Adds new fields to documents.\n   * Outputs documents that contain all existing fields from the input documents and newly added fields.\n   *\n   * @param {Array} collection\n   * @param {*} expr\n   */\n  $addFields: function (collection, expr) {\n    var newFields = keys(expr)\n\n    return collection.map(function (obj) {\n      obj = clone(obj)\n\n      each(newFields, function (selector) {\n        var subExpr = expr[selector]\n        var newValue\n\n        if (isObject(subExpr)) {\n          var subKeys = keys(subExpr)\n\n          // check for any operators first\n          var operator = subKeys.filter(function (k) {\n            return k.indexOf('$') === 0\n          })\n\n          if (!isEmpty(operator)) {\n            assert(subKeys.length === 1, 'Can have only one root operator in $addFields')\n            operator = operator[0]\n            subExpr = subExpr[operator]\n            newValue = computeValue(obj, subExpr, operator)\n          }\n        } else {\n          newValue = computeValue(obj, subExpr, null)\n        }\n\n        traverse(obj, selector, function (o, key) {\n          o[key] = newValue\n        }, true)\n      })\n\n      return obj\n    })\n  },\n\n  /**\n   * Groups documents together for the purpose of calculating aggregate values based on a collection of documents.\n   *\n   * @param collection\n   * @param expr\n   * @returns {Array}\n   */\n  $group: function (collection, expr) {\n    // lookup key for grouping\n    var idKey = expr[keyId()]\n\n    var partitions = groupBy(collection, function (obj) {\n      return computeValue(obj, idKey, idKey)\n    })\n\n    var result = []\n\n    // remove the group key\n    delete expr[keyId()]\n\n    each(partitions.keys, function (value, i) {\n      var obj = {}\n\n      // exclude undefined key value\n      if (!isUndefined(value)) {\n        obj[keyId()] = value\n      }\n\n      // compute remaining keys in expression\n      for (var key in expr) {\n        if (has(expr, key)) {\n          obj[key] = accumulate(partitions.groups[i], key, expr[key])\n        }\n      }\n      result.push(obj)\n    })\n\n    return result\n  },\n\n  /**\n   * Performs a left outer join to another collection in the same database to filter in documents from the joined collection for processing.\n   *\n   * @param collection\n   * @param expr\n   */\n  $lookup: function (collection, expr) {\n    var joinColl = expr.from\n    var localField = expr.localField\n    var foreignField = expr.foreignField\n    var asField = expr.as\n\n    var errorMsg = \"Invalid $lookup expression. \"\n    assert(isArray(joinColl), errorMsg + \"'from' must be an array\")\n    assert(isString(foreignField), errorMsg + \"'foreignField' must be a string\")\n    assert(isString(localField), errorMsg + \"'localField' must be a string\")\n    assert(isString(asField), errorMsg + \"'as' must be a string\")\n\n    var result = []\n    var hash = {}\n    function hashCode (v) { return getHash(isNil(v)? null : v) }\n\n    if (joinColl.length <= collection.length) {\n      each(joinColl, function (obj, i) {\n        var k = hashCode(obj[foreignField])\n        hash[k] = hash[k] || []\n        hash[k].push(i)\n      })\n\n      each(collection, function (obj) {\n        var k = hashCode(obj[localField])\n        var indexes = hash[k] || []\n        var newObj = clone(obj)\n        newObj[asField] = map(indexes, function (i) {\n          return clone(joinColl[i])\n        })\n        result.push(newObj)\n      })\n\n    } else {\n\n      each(collection, function (obj, i) {\n        var k = hashCode(obj[localField])\n        hash[k] = hash[k] || []\n        hash[k].push(i)\n      })\n\n      var tempResult = {}\n      each(joinColl, function (obj) {\n        var k = hashCode(obj[foreignField])\n        var indexes = hash[k] || []\n        each(indexes, function (i) {\n          var newObj = tempResult[i] || clone(collection[i])\n          newObj[asField] = newObj[asField] || []\n          newObj[asField].push(clone(obj))\n          tempResult[i] = newObj\n        })\n      })\n      for (var i = 0, len = keys(tempResult).length; i < len; i++) {\n        result.push(tempResult[i])\n      }\n    }\n\n    return result\n  },\n\n  /**\n   * Filters the document stream, and only allows matching documents to pass into the next pipeline stage.\n   * $match uses standard MongoDB queries.\n   *\n   * @param collection\n   * @param expr\n   * @returns {Array|*}\n   */\n  $match: function (collection, expr) {\n    return (new Mingo.Query(expr)).find(collection).all()\n  },\n\n  /**\n   * Reshapes a document stream.\n   * $project can rename, add, or remove fields as well as create computed values and sub-documents.\n   *\n   * @param collection\n   * @param expr\n   * @returns {Array}\n   */\n  $project: function (collection, expr) {\n    if (isEmpty(expr)) {\n      return collection\n    }\n\n    // result collection\n    var projected = []\n    var objKeys = keys(expr)\n    var idOnlyExcludedExpression = false\n\n    // validate inclusion and exclusion\n    var check = [false, false]\n    each(objKeys, function (k) {\n      var v = expr[k]\n      if (k === keyId()) return\n      if (v === 0 || v === false) {\n        check[0] = true\n      } else {\n        check[1] = true\n      }\n      assert(check[0] !== check[1], 'Projection cannot have a mix of inclusion and exclusion.')\n    })\n\n    if (inArray(objKeys, keyId())) {\n      var id = expr[keyId()]\n      if (id === 0 || id === false) {\n        objKeys = objKeys.filter(notInArray.bind(null, [keyId()]))\n        assert(notInArray(objKeys, keyId()), 'Must not contain collections _id')\n        idOnlyExcludedExpression = isEmpty(objKeys)\n      }\n    } else {\n      // if not specified the add the ID field\n      objKeys.push(keyId())\n    }\n\n    each(collection, function (obj, i) {\n      var cloneObj = {}\n      var foundSlice = false\n      var foundExclusion = false\n      var dropKeys = []\n\n      if (idOnlyExcludedExpression) {\n        dropKeys.push(keyId())\n      }\n\n      each(objKeys, function (key) {\n        var subExpr = expr[key]\n        var value // final computed value of the key\n        var objValue // full object graph to value of the key\n\n        if (key !== keyId() && subExpr === 0) {\n          foundExclusion = true\n        }\n\n        if (key === keyId() && isEmpty(subExpr)) {\n          // tiny optimization here to skip over id\n          value = obj[key]\n        } else if (isString(subExpr)) {\n          value = computeValue(obj, subExpr, key)\n        } else if (subExpr === 1 || subExpr === true) {\n          // For direct projections, we use the resolved object value\n        } else if (isObject(subExpr)) {\n          var operator = keys(subExpr)\n          operator = operator.length > 1 ? false : operator[0]\n\n          if (inArray(ops(KEY_PROJECTION), operator)) {\n            // apply the projection operator on the operator expression for the key\n            if (operator === '$slice') {\n              // $slice is handled differently for aggregation and projection operations\n              if (array(subExpr[operator]).every(isNumber)) {\n                // $slice for projection operation\n                value = projectionOperators[operator](obj, subExpr[operator], key)\n                foundSlice = true\n              } else {\n                // $slice for aggregation operation\n                value = computeValue(obj, subExpr, key)\n              }\n            } else {\n              value = projectionOperators[operator](obj, subExpr[operator], key)\n            }\n          } else {\n            // compute the value for the sub expression for the key\n            value = computeValue(obj, subExpr, key)\n          }\n        } else {\n          dropKeys.push(key)\n          return\n        }\n\n        // clone resolved values\n        value = clone(value)\n        objValue = clone(resolveObj(obj, key))\n\n        if (!isUndefined(objValue)) {\n          Object.assign(cloneObj, objValue)\n        }\n        if (!isUndefined(value)) {\n          setValue(cloneObj, key, value)\n        }\n\n      })\n      // if projection included $slice operator\n      // Also if exclusion fields are found or we want to exclude only the id field\n      // include keys that were not explicitly excluded\n      if (foundSlice || foundExclusion || idOnlyExcludedExpression) {\n        cloneObj = Object.assign(clone(obj), cloneObj)\n        each(dropKeys, function (key) {\n          removeValue(cloneObj, key)\n        })\n      }\n      projected.push(cloneObj)\n    })\n\n    return projected\n  },\n\n  /**\n   * Restricts the number of documents in an aggregation pipeline.\n   *\n   * @param collection\n   * @param value\n   * @returns {Object|*}\n   */\n  $limit: function (collection, value) {\n    return collection.slice(0, value)\n  },\n\n  /**\n   * Skips over a specified number of documents from the pipeline and returns the rest.\n   *\n   * @param collection\n   * @param value\n   * @returns {*}\n   */\n  $skip: function (collection, value) {\n    return collection.slice(value)\n  },\n\n  /**\n   * Takes an array of documents and returns them as a stream of documents.\n   *\n   * @param collection\n   * @param expr\n   * @returns {Array}\n   */\n  $unwind: function (collection, expr) {\n    var result = []\n    var field = expr.substr(1)\n    for (var i = 0; i < collection.length; i++) {\n      var obj = collection[i]\n      // must throw an error if value is not an array\n      var value = getValue(obj, field)\n      if (isArray(value)) {\n        each(value, function (item) {\n          var tmp = clone(obj)\n          tmp[field] = item\n          result.push(tmp)\n        })\n      } else {\n        except(\"Target field '\" + field + \"' is not of type Array.\")\n      }\n    }\n    return result\n  },\n\n  /**\n   * Takes all input documents and returns them in a stream of sorted documents.\n   *\n   * @param collection\n   * @param sortKeys\n   * @returns {*}\n   */\n  $sort: function (collection, sortKeys) {\n    if (!isEmpty(sortKeys) && isObject(sortKeys)) {\n      var modifiers = keys(sortKeys)\n      each(modifiers.reverse(), function (key) {\n        var grouped = groupBy(collection, function (obj) {\n          return resolve(obj, key)\n        })\n        var sortedIndex = {}\n        var findIndex = function (k) { return sortedIndex[getHash(k)] }\n\n        var indexKeys = sortBy(grouped.keys, function (item, i) {\n          sortedIndex[getHash(item)] = i\n          return item\n        })\n\n        if (sortKeys[key] === -1) {\n          indexKeys.reverse()\n        }\n        collection = []\n        each(indexKeys, function (item) {\n          into(collection, grouped.groups[findIndex(item)])\n        })\n      })\n    }\n    return collection\n  },\n\n  /**\n   * Groups incoming documents based on the value of a specified expression,\n   * then computes the count of documents in each distinct group.\n   *\n   * https://docs.mongodb.com/manual/reference/operator/aggregation/sortByCount/\n   *\n   * @param  {Array} collection\n   * @param  {Object} expr\n   * @return {*}\n   */\n  $sortByCount: function (collection, expr) {\n    var newExpr = { count: { $sum: 1 } }\n    newExpr[keyId()] = expr\n\n    return this.$sort(\n      this.$group(collection, newExpr),\n      { count: -1 }\n    )\n  },\n\n  /**\n   * Randomly selects the specified number of documents from its input.\n   * https://docs.mongodb.com/manual/reference/operator/aggregation/sample/\n   *\n   * @param  {Array} collection\n   * @param  {Object} expr\n   * @return {*}\n   */\n  $sample: function (collection, expr) {\n    var size = expr['size']\n    assert(isNumber(size), '$sample size must be a positive integer')\n\n    var result = []\n    for (var i = 0; i < size; i++) {\n      var n = Math.floor(Math.random() * collection.length)\n      result.push(collection[n])\n    }\n    return result\n  },\n\n  /**\n   * Returns a document that contains a count of the number of documents input to the stage.\n   * @param  {Array} collection\n   * @param  {String} expr\n   * @return {Object}\n   */\n  $count: function (collection, expr) {\n    assert(\n      isString(expr) && expr.trim() !== '' && expr.indexOf('.') === -1 && expr.trim()[0] !== '$',\n      'Invalid expression value for $count'\n    )\n\n    var result = {}\n    result[expr] = collection.length\n    return result\n  },\n\n  /**\n   * Replaces a document with the specified embedded document or new one.\n   * The replacement document can be any valid expression that resolves to a document.\n   *\n   * https://docs.mongodb.com/manual/reference/operator/aggregation/replaceRoot/\n   *\n   * @param  {Array} collection\n   * @param  {Object} expr\n   * @return {*}\n   */\n  $replaceRoot: function (collection, expr) {\n    var newRoot = expr['newRoot']\n    var result = []\n    each(collection, function (obj) {\n      obj = computeValue(obj, newRoot, null)\n      assert(isObject(obj), '$replaceRoot expression must return a valid JS object')\n      result.push(obj)\n    })\n    return result\n  },\n\n  /**\n   * Restricts the contents of the documents based on information stored in the documents themselves.\n   *\n   * https://docs.mongodb.com/manual/reference/operator/aggregation/redact/\n   */\n  $redact: function (collection, expr) {\n    return collection.map(function (obj) {\n      return redactObj(clone(obj), expr)\n    })\n  },\n}\n\n/**\n * Returns the result of evaluating a $group operation over a collection\n *\n * @param collection\n * @param field the name of the aggregate operator or field\n * @param expr the expression of the aggregate operator for the field\n * @returns {*}\n */\nfunction accumulate (collection, field, expr) {\n  if (inArray(ops(KEY_GROUP), field)) {\n    return groupOperators[field](collection, expr)\n  }\n\n  if (isObject(expr)) {\n    var result = {}\n    for (var key in expr) {\n      if (has(expr, key)) {\n        result[key] = accumulate(collection, key, expr[key])\n        // must run ONLY one group operator per expression\n        // if so, return result of the computed value\n        if (inArray(ops(KEY_GROUP), key)) {\n          result = result[key]\n          // if there are more keys in expression this is bad\n          if (keys(expr).length > 1) {\n            err(\"Invalid $group expression '\" + stringify(expr) + \"'\")\n          }\n          break\n        }\n      }\n    }\n    return result\n  }\n\n  return undefined\n}\n/**\n * Projection Operators. https://docs.mongodb.com/manual/reference/operator/projection/\n */\n\nvar projectionOperators = {\n\n  /**\n   * Projects the first element in an array that matches the query condition.\n   *\n   * @param obj\n   * @param field\n   * @param expr\n   */\n  $: function (obj, expr, field) {\n    err('$ not implemented')\n  },\n\n  /**\n   * Projects only the first element from an array that matches the specified $elemMatch condition.\n   *\n   * @param obj\n   * @param field\n   * @param expr\n   * @returns {*}\n   */\n  $elemMatch: function (obj, expr, field) {\n    var array = resolve(obj, field)\n    var query = new Mingo.Query(expr)\n\n    if (isUndefined(array) || !isArray(array)) {\n      return undefined\n    }\n\n    for (var i = 0; i < array.length; i++) {\n      if (query.test(array[i])) {\n        return [array[i]]\n      }\n    }\n\n    return undefined\n  },\n\n  /**\n   * Limits the number of elements projected from an array. Supports skip and limit slices.\n   *\n   * @param obj\n   * @param field\n   * @param expr\n   */\n  $slice: function (obj, expr, field) {\n    var xs = resolve(obj, field)\n\n    if (!isArray(xs)) return xs\n\n    if (isArray(expr)) {\n      return slice(xs, expr[0], expr[1])\n    } else if (isNumber(expr)) {\n      return slice(xs, expr)\n    } else {\n      err('Invalid argument type for $slice projection operator')\n    }\n  },\n\n  /**\n   * Returns the population standard deviation of the input values.\n   * @param  {Array} collection\n   * @param  {Object} expr\n   * @return {Number}\n   */\n  $stdDevPop: function (obj, expr, field) {\n    var dataset = computeValue(obj, expr, field)\n    return stddev({ dataset: dataset, sampled: false })\n  },\n\n  /**\n   * Returns the sample standard deviation of the input values.\n   * @param  {Array} collection\n   * @param  {Object} expr\n   * @return {Number|null}\n   */\n  $stdDevSamp: function (obj, expr, field) {\n    var dataset = computeValue(obj, expr, field)\n    return stddev({ dataset: dataset, sampled: true })\n  }\n}\n/**\n * Query and Projection Operators. https://docs.mongodb.com/manual/reference/operator/query/\n */\n\nvar simpleOperators = {\n\n  /**\n   * Checks that two values are equal. Pseudo operator introduced for convenience and consistency\n   *\n   * @param a         The lhs operand as resolved from the object by the given selector\n   * @param b         The rhs operand provided by the user\n   * @returns {*}\n   */\n  $eq: function (a, b) {\n    return isEqual(a, b) || (isArray(a) && a.findIndex(isEqual.bind(null, b)) !== -1)\n  },\n\n  /**\n   * Matches all values that are not equal to the value specified in the query.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $ne: function (a, b) {\n    return !this.$eq(a, b)\n  },\n\n  /**\n   * Matches any of the values that exist in an array specified in the query.\n   *\n   * @param a\n   * @param b\n   * @returns {*}\n   */\n  $in: function (a, b) {\n    a = array(a)\n    return intersection(a, b).length > 0\n  },\n\n  /**\n   * Matches values that do not exist in an array specified to the query.\n   *\n   * @param a\n   * @param b\n   * @returns {*|boolean}\n   */\n  $nin: function (a, b) {\n    return isUndefined(a) || !this.$in(a, b)\n  },\n\n  /**\n   * Matches values that are less than the value specified in the query.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $lt: function (a, b) {\n    a = array(a).find(function (val) {\n      return val < b\n    })\n    return a !== undefined\n  },\n\n  /**\n   * Matches values that are less than or equal to the value specified in the query.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $lte: function (a, b) {\n    a = array(a).find(function (val) {\n      return val <= b\n    })\n    return a !== undefined\n  },\n\n  /**\n   * Matches values that are greater than the value specified in the query.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $gt: function (a, b) {\n    a = array(a).find(function (val) {\n      return val > b\n    })\n    return a !== undefined\n  },\n\n  /**\n   * Matches values that are greater than or equal to the value specified in the query.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $gte: function (a, b) {\n    a = array(a).find(function (val) {\n      return val >= b\n    })\n    return a !== undefined\n  },\n\n  /**\n   * Performs a modulo operation on the value of a field and selects documents with a specified result.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $mod: function (a, b) {\n    a = array(a).find(function (val) {\n      return isNumber(val) && isArray(b) && b.length === 2 && (val % b[0]) === b[1]\n    })\n    return a !== undefined\n  },\n\n  /**\n   * Selects documents where values match a specified regular expression.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $regex: function (a, b) {\n    a = array(a).find(function (val) {\n      return isString(val) && isRegExp(b) && (!!val.match(b))\n    })\n    return a !== undefined\n  },\n\n  /**\n   * Matches documents that have the specified field.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $exists: function (a, b) {\n    return (b === false && isUndefined(a)) || (b === true && !isUndefined(a))\n  },\n\n  /**\n   * Matches arrays that contain all elements specified in the query.\n   *\n   * @param a\n   * @param b\n   * @returns boolean\n   */\n  $all: function (a, b) {\n    var self = this\n    var matched = false\n    if (isArray(a) && isArray(b)) {\n      for (var i = 0; i < b.length; i++) {\n        if (isObject(b[i]) && inArray(keys(b[i]), '$elemMatch')) {\n          matched = matched || self.$elemMatch(a, b[i].$elemMatch)\n        } else {\n          // order of arguments matter\n          return intersection(b, a).length === b.length\n        }\n      }\n    }\n    return matched\n  },\n\n  /**\n   * Selects documents if the array field is a specified size.\n   *\n   * @param a\n   * @param b\n   * @returns {*|boolean}\n   */\n  $size: function (a, b) {\n    return isArray(a) && isNumber(b) && (a.length === b)\n  },\n\n  /**\n   * Selects documents if element in the array field matches all the specified $elemMatch condition.\n   *\n   * @param a\n   * @param b\n   */\n  $elemMatch: function (a, b) {\n    if (isArray(a) && !isEmpty(a)) {\n      var query = new Mingo.Query(b)\n      for (var i = 0; i < a.length; i++) {\n        if (query.test(a[i])) {\n          return true\n        }\n      }\n    }\n    return false\n  },\n\n  /**\n   * Selects documents if a field is of the specified type.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $type: function (a, b) {\n    switch (b) {\n      case 1:\n        return isNumber(a) && (a + '').indexOf('.') !== -1\n      case 2:\n      case 5:\n        return isString(a)\n      case 3:\n        return isObject(a)\n      case 4:\n        return isArray(a)\n      case 8:\n        return isBoolean(a)\n      case 9:\n        return isDate(a)\n      case 10:\n        return isNull(a)\n      case 11:\n        return isRegExp(a)\n      case 16:\n        return isNumber(a) && a <= 2147483647 && (a + '').indexOf('.') === -1\n      case 18:\n        return isNumber(a) && a > 2147483647 && a <= 9223372036854775807 && (a + '').indexOf('.') === -1\n      default:\n        return false\n    }\n  }\n}\n\nvar queryOperators = {\n\n  /**\n   * Joins query clauses with a logical AND returns all documents that match the conditions of both clauses.\n   *\n   * @param selector\n   * @param value\n   * @returns {{test: Function}}\n   */\n  $and: function (selector, value) {\n    assert(isArray(value), 'Invalid expression: $and expects value to be an Array')\n    var queries = []\n    each(value, function (expr) {\n      queries.push(new Mingo.Query(expr))\n    })\n\n    return {\n      test: function (obj) {\n        for (var i = 0; i < queries.length; i++) {\n          if (!queries[i].test(obj)) {\n            return false\n          }\n        }\n        return true\n      }\n    }\n  },\n\n  /**\n   * Joins query clauses with a logical OR returns all documents that match the conditions of either clause.\n   *\n   * @param selector\n   * @param value\n   * @returns {{test: Function}}\n   */\n  $or: function (selector, value) {\n    if (!isArray(value)) {\n      err('Invalid expression for $or criteria')\n    }\n    var queries = []\n    each(value, function (expr) {\n      queries.push(new Mingo.Query(expr))\n    })\n\n    return {\n      test: function (obj) {\n        for (var i = 0; i < queries.length; i++) {\n          if (queries[i].test(obj)) {\n            return true\n          }\n        }\n        return false\n      }\n    }\n  },\n\n  /**\n   * Joins query clauses with a logical NOR returns all documents that fail to match both clauses.\n   *\n   * @param selector\n   * @param value\n   * @returns {{test: Function}}\n   */\n  $nor: function (selector, value) {\n    if (!isArray(value)) {\n      err('Invalid expression for $nor criteria')\n    }\n    var query = this.$or('$or', value)\n    return {\n      test: function (obj) {\n        return !query.test(obj)\n      }\n    }\n  },\n\n  /**\n   * Inverts the effect of a query expression and returns documents that do not match the query expression.\n   *\n   * @param selector\n   * @param value\n   * @returns {{test: Function}}\n   */\n  $not: function (selector, value) {\n    var criteria = {}\n    criteria[selector] = normalize(value)\n    var query = new Mingo.Query(criteria)\n    return {\n      test: function (obj) {\n        return !query.test(obj)\n      }\n    }\n  },\n\n  /**\n   * Matches documents that satisfy a JavaScript expression.\n   *\n   * @param selector\n   * @param value\n   * @returns {{test: test}}\n   */\n  $where: function (selector, value) {\n    if (!isFunction(value)) {\n      value = new Function('return ' + value + ';')\n    }\n    return {\n      test: function (obj) {\n        return value.call(obj) === true\n      }\n    }\n  }\n}\n\n// add simple query operators\neach(simpleOperators, function (fn, op) {\n  queryOperators[op] = (function (f, ctx) {\n    return function (selector, value) {\n      return {\n        test: function (obj) {\n          // value of field must be fully resolved.\n          var lhs = resolve(obj, selector)\n          return f.call(ctx, lhs, value)\n        }\n      }\n    }\n  }(fn, simpleOperators))\n})\nvar arithmeticOperators = {\n\n  /**\n   * Returns the absolute value of a number.\n   * https://docs.mongodb.com/manual/reference/operator/aggregation/abs/#exp._S_abs\n   * @param obj\n   * @param expr\n   * @return {Number|null|NaN}\n   */\n  $abs: function (obj, expr) {\n    var val = computeValue(obj, expr, null)\n    return (val === null || val === undefined) ? null : Math.abs(val)\n  },\n\n  /**\n   * Computes the sum of an array of numbers.\n   *\n   * @param obj\n   * @param expr\n   * @returns {Object}\n   */\n  $add: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    return args.reduce(function (memo, num) {\n      return memo + num\n    }, 0)\n  },\n\n  /**\n   * Returns the smallest integer greater than or equal to the specified number.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $ceil: function (obj, expr) {\n    var arg = computeValue(obj, expr, null)\n    if (isNaN(arg)) return NaN\n    if (isNil(arg)) return null\n    assert(isNumber(arg), '$ceil must be a valid expression that resolves to a number.')\n    return Math.ceil(arg)\n  },\n\n  /**\n   * Takes two numbers and divides the first number by the second.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $divide: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    return args[0] / args[1]\n  },\n\n  /**\n   * Raises Eulers number (i.e. e ) to the specified exponent and returns the result.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $exp: function (obj, expr) {\n    var arg = computeValue(obj, expr, null)\n    if (isNaN(arg)) return NaN\n    if (isNil(arg)) return null\n    assert(isNumber(arg), '$exp must be a valid expression that resolves to a number.')\n    return Math.exp(arg)\n  },\n\n  /**\n   * Returns the largest integer less than or equal to the specified number.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $floor: function (obj, expr) {\n    var arg = computeValue(obj, expr, null)\n    if (isNaN(arg)) return NaN\n    if (isNil(arg)) return null\n    assert(isNumber(arg), '$floor must be a valid expression that resolves to a number.')\n    return Math.floor(arg)\n  },\n\n  /**\n   * Calculates the natural logarithm ln (i.e loge) of a number and returns the result as a double.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $ln: function (obj, expr) {\n    var arg = computeValue(obj, expr, null)\n    if (isNaN(arg)) return NaN\n    if (isNil(arg)) return null\n    assert(isNumber(arg), '$ln must be a valid expression that resolves to a number.')\n    return Math.log(arg)\n  },\n\n  /**\n   * Calculates the log of a number in the specified base and returns the result as a double.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $log: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    assert(isArray(args) && args.length === 2, '$log must be a valid expression that resolves to an array of 2 items')\n    if (args.some(isNaN)) return NaN\n    if (args.some(isNil)) return null\n    assert(args.every(isNumber), '$log expression must resolve to array of 2 numbers')\n    return Math.log10(args[0]) / Math.log10(args[1])\n  },\n\n  /**\n   * Calculates the log base 10 of a number and returns the result as a double.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $log10: function (obj, expr) {\n    var arg = computeValue(obj, expr, null)\n    if (isNaN(arg)) return NaN\n    if (isNil(arg)) return null\n    assert(isNumber(arg), '$log10 must be a valid expression that resolves to a number.')\n    return Math.log10(arg)\n  },\n\n  /**\n   * Takes two numbers and calculates the modulo of the first number divided by the second.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $mod: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    return args[0] % args[1]\n  },\n\n  /**\n   * Computes the product of an array of numbers.\n   *\n   * @param obj\n   * @param expr\n   * @returns {Object}\n   */\n  $multiply: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    return args.reduce(function (memo, num) {\n      return memo * num\n    }, 1)\n  },\n\n  /**\n   * Raises a number to the specified exponent and returns the result.\n   *\n   * @param obj\n   * @param expr\n   * @returns {Object}\n   */\n  $pow: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    assert(isArray(args) && args.length === 2 && args.every(isNumber), '$pow must be a valid expression that resolves to an array of 2 numbers')\n\n    if (args[0] === 0 && args[1] < 0) err('$pow cannot raise 0 to a negative exponent')\n\n    return Math.pow(args[0], args[1])\n  },\n\n  /**\n   * Calculates the square root of a positive number and returns the result as a double.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $sqrt: function (obj, expr) {\n    var n = computeValue(obj, expr, null)\n    if (isNaN(n)) return NaN\n    if (isNil(n)) return null\n    assert(isNumber(n) && n > 0, '$sqrt must be a valid expression that resolves to a non-negative number.')\n    return Math.sqrt(n)\n  },\n\n  /**\n   * Takes an array that contains two numbers or two dates and subtracts the second value from the first.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $subtract: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    return args[0] - args[1]\n  },\n\n  /**\n   * Truncates a number to its integer.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $trunc: function (obj, expr) {\n    var n = computeValue(obj, expr, null)\n    if (isNaN(n)) return NaN\n    if (isNil(n)) return null\n    assert(isNumber(n) && n > 0, '$trunc must be a valid expression that resolves to a non-negative number.')\n    return Math.trunc(n)\n  }\n}\n\nvar arrayOperators = {\n  /**\n   * Returns the element at the specified array index.\n   *\n   * @param  {Object} obj\n   * @param  {*} expr\n   * @return {*}\n   */\n  $arrayElemAt: function (obj, expr) {\n    var arr = computeValue(obj, expr, null)\n    assert(isArray(arr) && arr.length === 2, '$arrayElemAt expression must resolve to an array of 2 elements')\n    assert(isArray(arr[0]), 'First operand to $arrayElemAt must resolve to an array')\n    assert(isNumber(arr[1]), 'Second operand to $arrayElemAt must resolve to an integer')\n    var idx = arr[1]\n    arr = arr[0]\n    if (idx < 0 && Math.abs(idx) <= arr.length) {\n      return arr[idx + arr.length]\n    } else if (idx >= 0 && idx < arr.length) {\n      return arr[idx]\n    }\n    return undefined\n  },\n\n  /**\n   * Concatenates arrays to return the concatenated array.\n   *\n   * @param  {Object} obj\n   * @param  {*} expr\n   * @return {*}\n   */\n  $concatArrays: function (obj, expr) {\n    var arr = computeValue(obj, expr, null)\n    assert(isArray(arr) && arr.length === 2, '$concatArrays expression must resolve to an array of 2 elements')\n\n    if (arr.some(isNil)) return null\n\n    return arr[0].concat(arr[1])\n  },\n\n  /**\n   * Selects a subset of the array to return an array with only the elements that match the filter condition.\n   *\n   * @param  {Object} obj  [description]\n   * @param  {*} expr [description]\n   * @return {*}      [description]\n   */\n  $filter: function (obj, expr) {\n    var input = computeValue(obj, expr['input'], null)\n    var asVar = expr['as']\n    var condExpr = expr['cond']\n\n    assert(isArray(input), \"'input' expression for $filter must resolve to an array\")\n\n    return input.filter(function (o) {\n      // inject variable\n      var tempObj = {}\n      tempObj['$' + asVar] = o\n      return computeValue(tempObj, condExpr, null) === true\n    })\n  },\n\n  /**\n   * Searches an array for an occurence of a specified value and returns the array index of the first occurence.\n   * If the substring is not found, returns -1.\n   *\n   * @param  {Object} obj\n   * @param  {*} expr\n   * @return {*}\n   */\n  $indexOfArray: function (obj, expr) {\n    var arr = computeValue(obj, expr, null)\n    if (isNil(arr)) return null\n\n    var array = arr[0]\n    if (isNil(array)) return null\n\n    assert(isArray(array), 'First operand for $indexOfArray must resolve to an array.')\n\n    var searchValue = arr[1]\n    if (isNil(searchValue)) return null\n\n    var start = arr[2] || 0\n    var end = arr[3] || array.length\n\n    if (end < array.length) {\n      array = array.slice(start, end)\n    }\n\n    return array.indexOf(searchValue, start)\n  },\n\n  /**\n   * Determines if the operand is an array. Returns a boolean.\n   *\n   * @param  {Object}  obj\n   * @param  {*}  expr\n   * @return {Boolean}\n   */\n  $isArray: function (obj, expr) {\n    return isArray(computeValue(obj, expr, null))\n  },\n\n  /**\n   * Returns an array whose elements are a generated sequence of numbers.\n   *\n   * @param  {Object} obj\n   * @param  {*} expr\n   * @return {*}\n   */\n  $range: function (obj, expr) {\n    var arr = computeValue(obj, expr, null)\n    var start = arr[0]\n    var end = arr[1]\n    var step = arr[2] || 1\n\n    var result = []\n\n    while ((start < end && step > 0) || (start > end && step < 0)) {\n      result.push(start)\n      start += step\n    }\n\n    return result\n  },\n\n  /**\n   * Returns an array with the elements in reverse order.\n   *\n   * @param  {Object} obj\n   * @param  {*} expr\n   * @return {*}\n   */\n  $reverseArray: function (obj, expr) {\n    var arr = computeValue(obj, expr, null)\n\n    if (isNil(arr)) return null\n    assert(isArray(arr), '$reverseArray expression must resolve to an array')\n\n    var result = []\n    for (var i = arr.length - 1; i > -1; i--) {\n      result.push(arr[i])\n    }\n    return result\n  },\n\n  /**\n   * Applies an expression to each element in an array and combines them into a single value.\n   *\n   * @param {Object} obj\n   * @param {*} expr\n   */\n  $reduce: function (obj, expr) {\n    var input = computeValue(obj, expr['input'], null)\n    var initialValue = computeValue(obj, expr['initialValue'], null)\n    var inExpr = expr['in']\n\n    if (isNil(input)) return null\n    assert(isArray(input), \"'input' expression for $reduce must resolve to an array\")\n\n    return input.reduce(function (acc, n) {\n      return computeValue({ '$value': acc, '$this': n }, inExpr, null)\n    }, initialValue)\n  },\n\n  /**\n   * Counts and returns the total the number of items in an array.\n   *\n   * @param obj\n   * @param expr\n   */\n  $size: function (obj, expr) {\n    var value = computeValue(obj, expr, null)\n    return isArray(value) ? value.length : undefined\n  },\n\n  /**\n   * Returns a subset of an array.\n   *\n   * @param  {Object} obj\n   * @param  {*} expr\n   * @return {*}\n   */\n  $slice: function (obj, expr) {\n    var arr = computeValue(obj, expr, null)\n    return slice(arr[0], arr[1], arr[2])\n  },\n\n  /**\n   * Merge two lists together.\n   *\n   * Transposes an array of input arrays so that the first element of the output array would be an array containing,\n   * the first element of the first input array, the first element of the second input array, etc.\n   *\n   * @param  {Obj} obj\n   * @param  {*} expr\n   * @return {*}\n   */\n  $zip: function (obj, expr) {\n    var inputs = computeValue(obj, expr.inputs, null)\n    var useLongestLength = expr.useLongestLength || false\n\n    assert(isArray(inputs), \"'inputs' expression must resolve to an array\")\n    assert(isBoolean(useLongestLength), \"'useLongestLength' must be a boolean\")\n\n    if (isArray(expr.defaults)) {\n      assert(truthy(useLongestLength), \"'useLongestLength' must be set to true to use 'defaults'\")\n    }\n\n    var len = 0\n    var arr // temp variable\n    var i // loop counter\n\n    for (i = 0; i < inputs.length; i++) {\n      arr = inputs[i]\n\n      if (isNil(arr)) return null\n      assert(isArray(arr), \"'inputs' expression values must resolve to an array or null\")\n\n      len = useLongestLength\n        ? Math.max(len, arr.length)\n        : Math.min(len || arr.length, arr.length)\n    }\n\n    var result = []\n    var defaults = expr.defaults || []\n\n    for (i = 0; i < len; i++) {\n      arr = inputs.map(function (val, index) {\n        return isNil(val[i])\n          ? (defaults[index] || null)\n          : val[i]\n      })\n      result.push(arr)\n    }\n\n    return result\n  }\n}\n\nvar booleanOperators = {\n  /**\n   * Returns true only when all its expressions evaluate to true. Accepts any number of argument expressions.\n   * @param obj\n   * @param expr\n   * @returns {boolean}\n   */\n  $and: function (obj, expr) {\n    var value = computeValue(obj, expr, null)\n    return truthy(value) && value.every(truthy)\n  },\n\n  /**\n   * Returns true when any of its expressions evaluates to true. Accepts any number of argument expressions.\n   * @param obj\n   * @param expr\n   * @returns {boolean}\n   */\n  $or: function (obj, expr) {\n    var value = computeValue(obj, expr, null)\n    return truthy(value) && value.some(truthy)\n  },\n\n  /**\n   * Returns the boolean value that is the opposite of its argument expression. Accepts a single argument expression.\n   * @param obj\n   * @param expr\n   * @returns {boolean}\n   */\n  $not: function (obj, expr) {\n    return !computeValue(obj, expr[0], null)\n  }\n}\n\nvar comparisonOperators = {\n  /**\n   * Compares two values and returns the result of the comparison as an integer.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $cmp: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    if (args[0] > args[1]) return 1\n    if (args[0] < args[1]) return -1\n    return 0\n  }\n}\n// mixin comparison operators\neach(['$eq', '$ne', '$gt', '$gte', '$lt', '$lte', '$in', '$nin'], function (op) {\n  comparisonOperators[op] = function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    return simpleOperators[op](args[0], args[1])\n  }\n})\n\nvar conditionalOperators = {\n\n  /**\n   * A ternary operator that evaluates one expression,\n   * and depending on the result returns the value of one following expressions.\n   *\n   * @param obj\n   * @param expr\n   */\n  $cond: function (obj, expr) {\n    var ifExpr, thenExpr, elseExpr\n    if (isArray(expr)) {\n      if (expr.length !== 3) {\n        err('Invalid arguments for $cond operator')\n      }\n      ifExpr = expr[0]\n      thenExpr = expr[1]\n      elseExpr = expr[2]\n    } else if (isObject(expr)) {\n      ifExpr = expr['if']\n      thenExpr = expr['then']\n      elseExpr = expr['else']\n    }\n    var condition = computeValue(obj, ifExpr, null)\n    return condition ? computeValue(obj, thenExpr, null) : computeValue(obj, elseExpr, null)\n  },\n\n  /**\n   * An operator that evaluates a series of case expressions. When it finds an expression which\n   * evaluates to true, it returns the resulting expression for that case. If none of the cases\n   * evaluate to true, it returns the default expression.\n   *\n   * @param obj\n   * @param expr\n   */\n  $switch: function (obj, expr) {\n    if (!expr.branches) {\n      err('Invalid arguments for $switch operator')\n    }\n\n    var validBranch = expr.branches.find(function (branch) {\n      if (!(branch.case && branch.then)) {\n        err('Invalid arguments for $switch operator')\n      }\n      return computeValue(obj, branch.case, null)\n    })\n\n    if (validBranch) {\n      return computeValue(obj, validBranch.then, null)\n    } else if (!expr.default) {\n      err('Invalid arguments for $switch operator')\n    } else {\n      return computeValue(obj, expr.default, null)\n    }\n  },\n\n  /**\n   * Evaluates an expression and returns the first expression if it evaluates to a non-null value.\n   * Otherwise, $ifNull returns the second expression's value.\n   *\n   * @param obj\n   * @param expr\n   * @returns {*}\n   */\n  $ifNull: function (obj, expr) {\n    assert(isArray(expr) && expr.length === 2, 'Invalid arguments for $ifNull operator')\n    var args = computeValue(obj, expr, null)\n    return (args[0] === null || args[0] === undefined) ? args[1] : args[0]\n  }\n}\n\n// used for formatting dates in $dateToString operator\nvar DATE_SYM_TABLE = {\n  '%Y': ['$year', 4],\n  '%m': ['$month', 2],\n  '%d': ['$dayOfMonth', 2],\n  '%H': ['$hour', 2],\n  '%M': ['$minute', 2],\n  '%S': ['$second', 2],\n  '%L': ['$millisecond', 3],\n  '%j': ['$dayOfYear', 3],\n  '%w': ['$dayOfWeek', 1],\n  '%U': ['$week', 2],\n  '%%': '%'\n}\n\nvar dateOperators = {\n  /**\n   * Returns the day of the year for a date as a number between 1 and 366 (leap year).\n   * @param obj\n   * @param expr\n   */\n  $dayOfYear: function (obj, expr) {\n    var d = computeValue(obj, expr, null)\n    if (isDate(d)) {\n      var start = new Date(d.getFullYear(), 0, 0)\n      var diff = d - start\n      var oneDay = 1000 * 60 * 60 * 24\n      return Math.round(diff / oneDay)\n    }\n    return undefined\n  },\n\n  /**\n   * Returns the day of the month for a date as a number between 1 and 31.\n   * @param obj\n   * @param expr\n   */\n  $dayOfMonth: function (obj, expr) {\n    var d = computeValue(obj, expr, null)\n    return isDate(d) ? d.getDate() : undefined\n  },\n\n  /**\n   * Returns the day of the week for a date as a number between 1 (Sunday) and 7 (Saturday).\n   * @param obj\n   * @param expr\n   */\n  $dayOfWeek: function (obj, expr) {\n    var d = computeValue(obj, expr, null)\n    return isDate(d) ? d.getDay() + 1 : undefined\n  },\n\n  /**\n   * Returns the year for a date as a number (e.g. 2014).\n   * @param obj\n   * @param expr\n   */\n  $year: function (obj, expr) {\n    var d = computeValue(obj, expr, null)\n    return isDate(d) ? d.getFullYear() : undefined\n  },\n\n  /**\n   * Returns the month for a date as a number between 1 (January) and 12 (December).\n   * @param obj\n   * @param expr\n   */\n  $month: function (obj, expr) {\n    var d = computeValue(obj, expr, null)\n    return isDate(d) ? d.getMonth() + 1 : undefined\n  },\n\n  /**\n   * Returns the week number for a date as a number between 0\n   * (the partial week that precedes the first Sunday of the year) and 53 (leap year).\n   * @param obj\n   * @param expr\n   */\n  $week: function (obj, expr) {\n    // source: http://stackoverflow.com/a/6117889/1370481\n    var d = computeValue(obj, expr, null)\n\n    // Copy date so don't modify original\n    d = new Date(+d)\n    d.setHours(0, 0, 0)\n    // Set to nearest Thursday: current date + 4 - current day number\n    // Make Sunday's day number 7\n    d.setDate(d.getDate() + 4 - (d.getDay() || 7))\n    // Get first day of year\n    var yearStart = new Date(d.getFullYear(), 0, 1)\n    // Calculate full weeks to nearest Thursday\n    return Math.floor((((d - yearStart) / 8.64e7) + 1) / 7)\n  },\n\n  /**\n   * Returns the hour for a date as a number between 0 and 23.\n   * @param obj\n   * @param expr\n   */\n  $hour: function (obj, expr) {\n    var d = computeValue(obj, expr, null)\n    return isDate(d) ? d.getUTCHours() : undefined\n  },\n\n  /**\n   * Returns the minute for a date as a number between 0 and 59.\n   * @param obj\n   * @param expr\n   */\n  $minute: function (obj, expr) {\n    var d = computeValue(obj, expr, null)\n    return isDate(d) ? d.getMinutes() : undefined\n  },\n\n  /**\n   * Returns the seconds for a date as a number between 0 and 60 (leap seconds).\n   * @param obj\n   * @param expr\n   */\n  $second: function (obj, expr) {\n    var d = computeValue(obj, expr, null)\n    return isDate(d) ? d.getSeconds() : undefined\n  },\n\n  /**\n   * Returns the milliseconds of a date as a number between 0 and 999.\n   * @param obj\n   * @param expr\n   */\n  $millisecond: function (obj, expr) {\n    var d = computeValue(obj, expr, null)\n    return isDate(d) ? d.getMilliseconds() : undefined\n  },\n\n  /**\n   * Returns the date as a formatted string.\n   *\n   * %Y  Year (4 digits, zero padded)  0000-9999\n   * %m  Month (2 digits, zero padded)  01-12\n   * %d  Day of Month (2 digits, zero padded)  01-31\n   * %H  Hour (2 digits, zero padded, 24-hour clock)  00-23\n   * %M  Minute (2 digits, zero padded)  00-59\n   * %S  Second (2 digits, zero padded)  00-60\n   * %L  Millisecond (3 digits, zero padded)  000-999\n   * %j  Day of year (3 digits, zero padded)  001-366\n   * %w  Day of week (1-Sunday, 7-Saturday)  1-7\n   * %U  Week of year (2 digits, zero padded)  00-53\n   * %%  Percent Character as a Literal  %\n   *\n   * @param obj current object\n   * @param expr operator expression\n   */\n  $dateToString: function (obj, expr) {\n    var fmt = expr['format']\n    var date = computeValue(obj, expr['date'], null)\n    var matches = fmt.match(/(%%|%Y|%m|%d|%H|%M|%S|%L|%j|%w|%U)/g)\n\n    for (var i = 0, len = matches.length; i < len; i++) {\n      var hdlr = DATE_SYM_TABLE[matches[i]]\n      var value = hdlr\n\n      if (isArray(hdlr)) {\n        // reuse date operators\n        var fn = this[hdlr[0]]\n        var pad = hdlr[1]\n        value = padDigits(fn.call(this, obj, date), pad)\n      }\n      // replace the match with resolved value\n      fmt = fmt.replace(matches[i], value)\n    }\n\n    return fmt\n  }\n}\n\nfunction padDigits (number, digits) {\n  return new Array(Math.max(digits - String(number).length + 1, 0)).join('0') + number\n}\n\nvar literalOperators = {\n  /**\n   * Return a value without parsing.\n   * @param obj\n   * @param expr\n   */\n  $literal: function (obj, expr) {\n    return expr\n  }\n}\n\nvar setOperators = {\n  /**\n   * Returns true if two sets have the same elements.\n   * @param obj\n   * @param expr\n   */\n  $setEquals: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    var xs = unique(args[0])\n    var ys = unique(args[1])\n    return xs.length === ys.length && xs.length === intersection(xs, ys).length\n  },\n\n  /**\n   * Returns the common elements of the input sets.\n   * @param obj\n   * @param expr\n   */\n  $setIntersection: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    return intersection(args[0], args[1])\n  },\n\n  /**\n   * Returns elements of a set that do not appear in a second set.\n   * @param obj\n   * @param expr\n   */\n  $setDifference: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    return args[0].filter(notInArray.bind(null, args[1]))\n  },\n\n  /**\n   * Returns a set that holds all elements of the input sets.\n   * @param obj\n   * @param expr\n   */\n  $setUnion: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    return union(args[0], args[1])\n  },\n\n  /**\n   * Returns true if all elements of a set appear in a second set.\n   * @param obj\n   * @param expr\n   */\n  $setIsSubset: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    return intersection(args[0], args[1]).length === args[0].length\n  },\n\n  /**\n   * Returns true if any elements of a set evaluate to true, and false otherwise.\n   * @param obj\n   * @param expr\n   */\n  $anyElementTrue: function (obj, expr) {\n    // mongodb nests the array expression in another\n    var args = computeValue(obj, expr, null)[0]\n    return args.some(truthy)\n  },\n\n  /**\n   * Returns true if all elements of a set evaluate to true, and false otherwise.\n   * @param obj\n   * @param expr\n   */\n  $allElementsTrue: function (obj, expr) {\n    // mongodb nests the array expression in another\n    var args = computeValue(obj, expr, null)[0]\n    return args.every(truthy)\n  }\n}\n\nvar stringOperators = {\n\n  /**\n   * Concatenates two strings.\n   *\n   * @param obj\n   * @param expr\n   * @returns {string|*}\n   */\n  $concat: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    // does not allow concatenation with nulls\n    if ([null, undefined].some(inArray.bind(null, args))) {\n      return null\n    }\n    return args.join('')\n  },\n\n  /**\n   * Searches a string for an occurence of a substring and returns the UTF-8 code point index of the first occurence.\n   * If the substring is not found, returns -1.\n   *\n   * @param  {Object} obj\n   * @param  {*} expr\n   * @return {*}\n   */\n  $indexOfBytes: function (obj, expr) {\n    var arr = computeValue(obj, expr, null)\n\n    if (isNil(arr[0])) return null\n\n    assert(isString(arr[0]), '$indexOfBytes first operand must resolve to a string')\n    assert(isString(arr[1]), '$indexOfBytes second operand must resolve to a string')\n\n    var str = arr[0]\n    var searchStr = arr[1]\n    var start = arr[2]\n    var end = arr[3]\n\n    assert(\n      isUndefined(start) || (isNumber(start) && start >= 0 && Math.round(start) === start),\n      '$indexOfBytes third operand must resolve to a non-negative integer'\n    )\n    start = start || 0\n\n    assert(\n      isUndefined(end) || (isNumber(end) && end >= 0 && Math.round(end) === end),\n      '$indexOfBytes fourth operand must resolve to a non-negative integer'\n    )\n    end = end || str.length\n\n    if (start > end) return -1\n\n    var index = str.substring(start, end).indexOf(searchStr)\n    return (index > -1)\n      ? index + start\n      : index\n  },\n\n  /**\n   * Splits a string into substrings based on a delimiter.\n   * If the delimiter is not found within the string, returns an array containing the original string.\n   *\n   * @param  {Object} obj\n   * @param  {Array} expr\n   * @return {Array} Returns an array of substrings.\n   */\n  $split: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    assert(isString(args[0]), '$split requires an expression that evaluates to a string as a first argument, found: ' + getType(args[0]))\n    assert(isString(args[1]), '$split requires an expression that evaluates to a string as a second argument, found: ' + getType(args[1]))\n    return args[0].split(args[1])\n  },\n\n  /**\n   * Compares two strings and returns an integer that reflects the comparison.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $strcasecmp: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    args[0] = isEmpty(args[0]) ? '' : args[0].toUpperCase()\n    args[1] = isEmpty(args[1]) ? '' : args[1].toUpperCase()\n    if (args[0] > args[1]) {\n      return 1\n    }\n    return (args[0] < args[1]) ? -1 : 0\n  },\n\n  /**\n   * Returns a substring of a string, starting at a specified index position and including the specified number of characters.\n   * The index is zero-based.\n   *\n   * @param obj\n   * @param expr\n   * @returns {string}\n   */\n  $substr: function (obj, expr) {\n    var args = computeValue(obj, expr, null)\n    if (isString(args[0])) {\n      if (args[1] < 0) {\n        return ''\n      } else if (args[2] < 0) {\n        return args[0].substr(args[1])\n      } else {\n        return args[0].substr(args[1], args[2])\n      }\n    }\n    return ''\n  },\n\n  /**\n   * Converts a string to lowercase.\n   *\n   * @param obj\n   * @param expr\n   * @returns {string}\n   */\n  $toLower: function (obj, expr) {\n    var value = computeValue(obj, expr, null)\n    return isEmpty(value) ? '' : value.toLowerCase()\n  },\n\n  /**\n   * Converts a string to uppercase.\n   *\n   * @param obj\n   * @param expr\n   * @returns {string}\n   */\n  $toUpper: function (obj, expr) {\n    var value = computeValue(obj, expr, null)\n    return isEmpty(value) ? '' : value.toUpperCase()\n  }\n}\n\n/**\n * Aggregation framework variable operators\n */\n\nvar variableOperators = {\n  /**\n   * Applies a subexpression to each element of an array and returns the array of resulting values in order.\n   * @param obj\n   * @param expr\n   * @returns {Array|*}\n   */\n  $map: function (obj, expr) {\n    var inputExpr = computeValue(obj, expr['input'], null)\n    if (!isArray(inputExpr)) {\n      err('Input expression for $map must resolve to an array')\n    }\n    var asExpr = expr['as']\n    var inExpr = expr['in']\n\n    // HACK: add the \"as\" expression as a value on the object to take advantage of \"resolve()\"\n    // which will reduce to that value when invoked. The reference to the as expression will be prefixed with \"$$\".\n    // But since a \"$\" is stripped of before passing the name to \"resolve()\" we just need to prepend \"$\" to the key.\n    var tempKey = '$' + asExpr\n    // let's save any value that existed, kinda useless but YOU CAN NEVER BE TOO SURE, CAN YOU :)\n    var original = obj[tempKey]\n    return inputExpr.map(function (item) {\n      obj[tempKey] = item\n      var value = computeValue(obj, inExpr, null)\n      // cleanup and restore\n      if (isUndefined(original)) {\n        delete obj[tempKey]\n      } else {\n        obj[tempKey] = original\n      }\n      return value\n    })\n  },\n\n  /**\n   * Defines variables for use within the scope of a subexpression and returns the result of the subexpression.\n   * @param obj\n   * @param expr\n   * @returns {*}\n   */\n  $let: function (obj, expr) {\n    var varsExpr = expr['vars']\n    var inExpr = expr['in']\n\n    // resolve vars\n    var originals = {}\n    var varsKeys = keys(varsExpr)\n    each(varsKeys, function (key) {\n      var val = computeValue(obj, varsExpr[key], null)\n      var tempKey = '$' + key\n      // set value on object using same technique as in \"$map\"\n      originals[tempKey] = obj[tempKey]\n      obj[tempKey] = val\n    })\n\n    var value = computeValue(obj, inExpr, null)\n\n    // cleanup and restore\n    each(varsKeys, function (key) {\n      var tempKey = '$' + key\n      if (isUndefined(originals[tempKey])) {\n        delete obj[tempKey]\n      } else {\n        obj[tempKey] = originals[tempKey]\n      }\n    })\n\n    return value\n  }\n}\n\n// combine aggregate operators\nvar aggregateOperators = Object.assign(\n  {},\n  arithmeticOperators,\n  arrayOperators,\n  booleanOperators,\n  comparisonOperators,\n  conditionalOperators,\n  dateOperators,\n  literalOperators,\n  setOperators,\n  stringOperators,\n  variableOperators\n)\n\n/**\n * Keys specifying different operator classes\n */\nvar KEY_QUERY = Mingo.KEY_QUERY = Mingo.OP_QUERY = 'query'\nvar KEY_GROUP = Mingo.KEY_GROUP = Mingo.OP_GROUP = 'group'\nvar KEY_AGGREGATE = Mingo.KEY_AGGREGATE = Mingo.OP_AGGREGATE = 'aggregate'\nvar KEY_PIPELINE = Mingo.KEY_PIPELINE = Mingo.OP_PIPELINE = 'pipeline'\nvar KEY_PROJECTION = Mingo.KEY_PROJECTION = Mingo.OP_PROJECTION = 'projection'\n\n// operator definitions\nvar OPERATORS = {\n  'aggregate': aggregateOperators,\n  'group': groupOperators,\n  'pipeline': pipelineOperators,\n  'projection': projectionOperators,\n  'query': queryOperators\n}\n\n/**\n * Returns the operators defined for the given operator key\n *\n * @param {String} opClass The operator class to query. See `Mingo.KEY_$XXX` members\n */\nfunction ops (opClass) {\n  return keys(OPERATORS[opClass])\n}\n\n/**\n * Add new operators\n *\n * @param opClass the operator class to extend\n * @param fn a function returning an object of new operators\n */\nMingo.addOperators = function (opClass, fn) {\n\n  var newOperators = fn({\n    'computeValue': computeValue,\n    'key': keyId,\n    'ops': ops,\n    'resolve': resolve\n  })\n\n  // ensure correct type specified\n  assert(has(OPERATORS, opClass), \"Could not identify operator class '\" + opClass + \"'\")\n\n  var operators = OPERATORS[opClass]\n\n  // check for existing operators\n  each(newOperators, function (fn, op) {\n    assert(/^\\$\\w+$/.test(op), \"Invalid operator name '\" + op + \"'\")\n    assert(!has(operators, op), 'Operator ' + op + ' is already defined for ' + opClass + ' operators')\n  })\n\n  var wrapped = {}\n\n  switch (opClass) {\n    case KEY_QUERY:\n      each(newOperators, function (fn, op) {\n        wrapped[op] = (function (f, ctx) {\n          return function (selector, value) {\n            return {\n              test: function (obj) {\n                // value of field must be fully resolved.\n                var lhs = resolve(obj, selector)\n                var result = f.call(ctx, selector, lhs, value)\n                if (isBoolean(result)) {\n                  return result\n                } else if (result instanceof Query) {\n                  return result.test(obj)\n                } else {\n                  err(\"Invalid return type for '\" + op + \"'. Must return a Boolean or Mingo.Query\")\n                }\n              }\n            }\n          }\n        }(fn, newOperators))\n      })\n      break\n    case KEY_PROJECTION:\n      each(newOperators, function (fn, op) {\n        wrapped[op] = (function (f, ctx) {\n          return function (obj, expr, selector) {\n            var lhs = resolve(obj, selector)\n            return f.call(ctx, selector, lhs, expr)\n          }\n        }(fn, newOperators))\n      })\n      break\n    default:\n      each(newOperators, function (fn, op) {\n        wrapped[op] = (function (f, ctx) {\n          return function () {\n            var args = ArrayProto.slice.call(arguments)\n            return f.apply(ctx, args)\n          }\n        }(fn, newOperators))\n      })\n  }\n\n  // toss the operator salad :)\n  Object.assign(OPERATORS[opClass], wrapped)\n}\n\n/**\n * Performs a query on a collection and returns a cursor object.\n *\n * @param collection\n * @param criteria\n * @param projection\n * @returns {Mingo.Cursor}\n */\nMingo.find = function (collection, criteria, projection) {\n  return (new Mingo.Query(criteria)).find(collection, projection)\n}\n\n/**\n * Returns a new array without objects which match the criteria\n *\n * @param collection\n * @param criteria\n * @returns {Array}\n */\nMingo.remove = function (collection, criteria) {\n  return (new Mingo.Query(criteria)).remove(collection)\n}\n\n/**\n * Return the result collection after running the aggregation pipeline for the given collection\n *\n * @param collection\n * @param pipeline\n * @returns {Array}\n */\nMingo.aggregate = function (collection, pipeline) {\n  if (!isArray(pipeline)) {\n    err('Aggregation pipeline must be an array')\n  }\n  return (new Mingo.Aggregator(pipeline)).run(collection)\n}\n\n/**\n * Mixin for Collection types that provide a method `toJSON() -> Array[Object]`\n */\nMingo.CollectionMixin = {\n\n  /**\n   * Runs a query and returns a cursor to the result\n   * @param criteria\n   * @param projection\n   * @returns {Mingo.Cursor}\n   */\n  query: function (criteria, projection) {\n    return Mingo.find(this.toJSON(), criteria, projection)\n  },\n\n  /**\n   * Runs the given aggregation operators on this collection\n   * @params pipeline\n   * @returns {Array}\n   */\n  aggregate: function (pipeline) {\n    return Mingo.aggregate.call(null, this.toJSON(), pipeline)\n  }\n}\n\n\n// Export the Mingo object for Node.js\nif (typeof module !== 'undefined' && module.exports && typeof require !== 'undefined') {\n  module.exports = Mingo\n} else {\n  root.Mingo = Mingo\n}\n\n}(this))\n"}